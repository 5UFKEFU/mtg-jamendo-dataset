#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ÊâπÈáèÈü≥‰πêÊ†áÁ≠æ ‚Üí CSV + JSON
2025‚Äë04‚Äë19  ‚Äî  Êó†Â§ñÈÉ®‰æùËµñÁâà
"""

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ê†áÂáÜÂ∫ì ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import os, sys, csv, argparse, json, inspect
from datetime import datetime
from typing import List, Tuple

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ê∑±Â∫¶Â≠¶‰π† ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import torch, torchaudio, torch.nn.functional as F
import torch.nn as nn

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ëá™Âä®ÂØºÂÖ•Ê®°ÂûãÂÆö‰πâ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
HERE = os.path.dirname(os.path.abspath(__file__))
LABEL_MSD600_FILE = os.path.join(HERE, "label_msd600_zh.csv")

def import_models_pkg():
    SEARCH_PATHS = [
        os.path.join(HERE, "training"),
        os.path.join(HERE, "..", "training"),
        os.path.join(HERE, "models"),
    ]
    for p in SEARCH_PATHS:
        if os.path.isfile(os.path.join(p, "model.py")):
            sys.path.insert(0, p)
            import model as mdl
            return mdl
        if os.path.isfile(os.path.join(p, "__init__.py")):
            sys.path.insert(0, os.path.dirname(p))
            import models as mdl
            return mdl
    raise RuntimeError("‚ùå Êú™ÊâæÂà∞Ê®°ÂûãÂÆö‰πâ (model.py / models)„ÄÇËØ∑Ê£ÄÊü•ÁõÆÂΩï„ÄÇ")

md = import_models_pkg()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ê†áÁ≠æË°® ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
JAMENDO56: list[tuple[str, str]] = [
    # idx : (English      , ‰∏≠Êñá)
    ("serious", "‰∏•ËÇÉ"), ("relax", "ÊîæÊùæ"), ("dark", "ÈªëÊöó"), ("energetic", "ËÉΩÈáè"),
    ("acoustic", "ÂéüÂ£∞"), ("happy", "Âø´‰πê"), ("romantic", "Êµ™Êº´"), ("violent", "ÊøÄÁÉà"),
    ("sad", "ÊÇ≤‰º§"), ("epic", "Âè≤ËØó"), ("industrial", "Â∑•‰∏ö"), ("dramatic", "ÊàèÂâßÊÄß"),
    ("action", "Âä®‰Ωú"), ("hope", "Â∏åÊúõ"), ("mysterious", "Á•ûÁßò"), ("space", "Â§™Á©∫"),
    ("meditative", "ÂÜ•ÊÉ≥"), ("adventure", "ÂÜíÈô©"), ("documentary", "Á∫™ÂΩïÁâá"), ("nature", "Ëá™ÁÑ∂"),
    ("motivational", "Âä±Âøó"), ("sci‚Äëfi", "ÁßëÂπª"), ("christmas", "Âú£ËØû"), ("retro", "Â§çÂè§"),
    ("spy", "Ë∞çÊàò"), ("corporate", "‰ºÅ‰∏ö"), ("disco", "Ëø™ÊñØÁßë"), ("optimistic", "‰πêËßÇ"),
    ("advertising", "ÂπøÂëä"), ("dramatic building", "Ê∏êËøõÊàèÂâß"), ("kids", "ÂÑøÁ´•"), ("funk", "ÊîæÂÖã"),
    ("groovy", "ÂæãÂä®"), ("calm", "Âπ≥Èùô"), ("uplifting", "ÊèêÊåØ"), ("chill", "ËΩªÊùæ"),
    ("travel", "ÊóÖË°å"), ("melancholic", "ÂøßÈÉÅ"), ("party", "Ê¥æÂØπ"), ("fashion", "Êó∂Â∞ö"),
    ("spy/detective", "‰æ¶Êé¢"), ("positive", "ÁßØÊûÅ"), ("background", "ËÉåÊôØ"), ("powerful", "ÂäõÈáè"),
    ("sexy", "ÊÄßÊÑü"), ("groove", "ÂæãÂä®ÊÑü"), ("feelgood", "ËàíÁïÖ"), ("drama", "ÂâßÊÉÖ"),
    ("cool", "ÈÖ∑ÁÇ´"), ("adrenaline", "ËÇæ‰∏äËÖ∫Á¥†"), ("adrenalin", "ËÇæ‰∏äËÖ∫Á¥† (Âêå‰πâ)"), ("dreamy", "Ê¢¶Âπª"),
    ("inspiring", "ÈºìËàû"), ("energetic build", "ËÉΩÈáèÊ∏êËøõ"), ("funny", "ÂπΩÈªò"), ("victory", "ËÉúÂà©"),
    ("pensive", "Ê≤âÊÄù"), ("grooves", "ÂæãÂä®ÊÑü (Â§çÊï∞)"), ("tension", "Á¥ßÂº†")
]

MTAT50 = [
    "rock","pop","alternative","indie","electronic","female vocalists","dance","00s",
    "alternative rock","jazz","beautiful","metal","chillout","male vocalists",
    "classic rock","soul","indie rock","mellow","electronica","80s","folk","90s",
    "chill","instrumental","punk","oldies","blues","hard rock","ambient","acoustic",
    "experimental","female vocalist","guitar","hip-hop","70s","party","country",
    "easy listening","sexy","catchy","funk","electro","heavy metal","progressive rock",
    "60s","rnb","indie pop","sad","house","happy"
]

MSD50 = MTAT50

def load_msd600_labels() -> list[tuple[str, str]]:
    if not os.path.exists(LABEL_MSD600_FILE):
        print("‚ö†Ô∏è Êú™ÊâæÂà∞ label_msd600_zh.csvÔºå‰ΩøÁî®ÈªòËÆ§Ê†áÁ≠æ")
        return [(f"tag_{i:03d}",)*2 for i in range(600)]
    rows = []
    with open(LABEL_MSD600_FILE, encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or "," not in line:
                continue
            parts = line.split(",", 1)
            tag_en = parts[0].split(" ", 1)[-1]
            tag_zh = parts[1]
            rows.append((tag_en, tag_zh))
    print(f"üìñ Â∑≤Âä†ËΩΩ MSD600 Ê†áÁ≠æÔºö{len(rows)} Êù°")
    return rows

def tag_table(ds: str, ncls: int):
    if ds == "jamendo": return JAMENDO56
    if ds == "mtat":    return MTAT50
    if ds == "msd":     return MSD50 if ncls == 50 else load_msd600_labels()
    return []

# ‚¨áÔ∏è ÂÖ∂‰Ωô‰ª£Á†ÅÁª¥ÊåÅ‰∏çÂèòÔºåÂ¶ÇÊúâÂêéÁª≠ÈúÄÊ±ÇÂÜçËøõË°åÈõÜÊàê
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CLI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def cli():
    ap = argparse.ArgumentParser()
    ap.add_argument("--dataset", required=True,
                    choices=["jamendo", "mtat", "msd"])
    ap.add_argument("--model", required=True,
                    help="crnn / sample / se / short_res ‚Ä¶")
    ap.add_argument("--audio_folder", default="my_music")
    ap.add_argument("--top_k", type=int, default=10)
    ap.add_argument("--th", type=float, default=0.1)
    ap.add_argument("--exts", nargs="+", default=[".wav"])
    # ÈªòËÆ§Â∞±Áî®ÂΩìÂâçÁõÆÂΩï models/
    ap.add_argument("--model_root", default="models")
    ap.add_argument("--skip", default="", help="ÈÄóÂè∑ÂàÜÈöîÊ®°ÂûãÂêçÔºåË∑≥ËøáÈ¢ÑÊµã")
    return ap.parse_args()

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ I/O ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def list_audio(root: str, exts):
    exts = tuple(e.lower() for e in exts)
    return [os.path.join(r, f)
            for r, _, fs in os.walk(root)
            for f in fs if f.lower().endswith(exts)]

def wav_tensor(path: str, sr=16000, dur=30):
    w, fs = torchaudio.load(path)
    if fs != sr:
        w = torchaudio.transforms.Resample(fs, sr)(w)
    need = sr * dur
    return F.pad(w, (0, max(0, need - w.shape[1])))[:, :need]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ê®°ÂûãÊûÑÂª∫ / Âä†ËΩΩ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
MODEL_MAP = {
    "crnn": "CRNN", "fcn": "FCN", "sample": "SampleCNN", "se": "SampleCNNSE",
    "short": "ShortChunkCNN", "short_res": "ShortChunkCNN_Res",
    "attention": "CNNSA", "hcnn": "HarmonicCNN",
    "musicnn": "Musicnn", "musicnn600": "Musicnn"
}

# ‚ë† ÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºç build_model ÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºç
def build_model(key: str, ncls: int, ds: str, st: dict | None = None):
    """
    Ê†πÊçÆÊ®°ÂûãÂêçÂÆû‰æãÂåñÁΩëÁªúÔºõ
    Ëã• state_dict(st) ÁªôÂá∫ÊúÄÂêéÂÖ®ËøûÊé•Â±ÇÔºåËá™Âä®Êé®Êñ≠ hidden_dim/d_modelÔºåËß£ÂÜ≥ Attention
    ‚Äú(1√ó236) ‰∏é (256√ó256) Áª¥Â∫¶‰∏çÁ¨¶‚Äù ÁöÑÈóÆÈ¢ò„ÄÇ
    """
    cls = getattr(md, MODEL_MAP[key])

    # ‰ªé checkpoint Êé®Êñ≠ encoder hidden dimÔºàÊùÉÈáç shape: [n_classes, hidden_dim]Ôºâ
    hidden_dim = None
    if st is not None:
        for k, v in st.items():
            if k.endswith(".weight") and v.ndim == 2 and v.shape[0] == ncls:
                hidden_dim = v.shape[1]
                break

    base = dict(n_classes=ncls, dataset=ds)
    cand = [
        base,
        dict(num_classes=ncls, dataset=ds),
        dict(n_classes=ncls),
        dict(num_classes=ncls),
        dict(dataset=ds),
        {}
    ]
    # Ëã•Â∑≤Êé®Êñ≠ hidden_dimÔºåÊääÂ∏¶ d_model / hidden_size ÁöÑÁâàÊú¨ÊèíÂà∞ÊúÄÂâç
    if hidden_dim:
        cand = ([{**base, "d_model": hidden_dim},
                 {**base, "hidden_size": hidden_dim}] + cand)

    for kw in cand:
        try:
            return cls(**kw)
        except TypeError:
            continue
    raise RuntimeError(f"Êó†Ê≥ïÂÆû‰æãÂåñÊ®°Âûã {key}ÔºõÂ∞ùËØïÂèÇÊï∞Ôºö{cand}")

# ‚ë° ÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºç load_net ÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºçÔºç
def load_net(ckpt: str, key: str, ds: str):
    st = torch.load(ckpt, map_location=device)
    ncls = max(v.shape[0] for k, v in st.items()
               if k.endswith(".bias") and v.ndim == 1)
    net = build_model(key, ncls, ds, st)   # ‚Üê Êää st ‰º†ËøõÂéª
    net.load_state_dict(st, strict=False)
    #return patch_gap(net).to(device).eval(), ncls
    return patch_net(net).to(device).eval(), ncls     # ‚Üê ÊîπËøôÈáå
def patch_gap(net: nn.Module):
    """Ëã•ÊúÄÂêéÁ∫øÊÄßÂ±ÇÂâç‰ªçÊúâÊó∂Èó¥Áª¥ÔºåÂÅö GAP„ÄÇ"""
    if getattr(net, "_patched_gap", False):
        return net

    def gap_hook(_, inputs):
        x = inputs[0]
        if x.dim() == 3:  # [B, C, T]
            x = x.mean(-1)
            return (x,)
        return inputs

    for m in net.modules():
        if isinstance(m, nn.Linear):
            m.register_forward_pre_hook(gap_hook)
    net._patched_gap = True
    return net

# ---- ÈÄöÁî®Ë°•‰∏ÅÔºö‚ë† ÂÖ®Â±ÄÂπ≥ÂùáÊ±†Âåñ ‚ë° Á∫øÊÄßÂ±ÇËá™Âä®ÂØπÈΩê in_features ----
def patch_net(net: nn.Module):
    """
    ‚Ä¢ Ëã•ÈÄÅÂÖ• Linear Ââç‰ªçÂê´Êó∂Èó¥Áª¥ ‚Üí GAP
    ‚Ä¢ Ëã•ÁâπÂæÅÁª¥Â∫¶ ‚â† Linear.in_features:
        - Â∞è‰∫éÊó∂ ‚Üí Âè≥‰æß 0‚Äëpadding
        - Â§ß‰∫éÊó∂ ‚Üí Êà™Êñ≠Âà∞ÊâÄÈúÄÁª¥
      Ëß£ÂÜ≥ attention ÁöÑ (236 vs 256) Êä•ÈîôÔºå‰πüÂÆπÂøçÂà´ÁöÑÁª¥Â∫¶ÊºÇÁßª„ÄÇ
    Êâì‰∏ÄÊ¨°Ê†áËÆ∞Âç≥ÂèØ„ÄÇ
    """
    if getattr(net, "_patched_generic", False):
        return net

    def pre_hook(module, inputs):
        x = inputs[0]
        # ‚ë† time‚Äëdim GAPÔºöÂΩ¢Áä∂ [B,C,T] + in_features==C
        if x.dim() == 3 and x.size(1) == module.in_features:
            x = x.mean(-1)                    # -> [B,C]
        # ‚ë° ÂØπÈΩê feature Áª¥
        if x.size(-1) != module.in_features:
            diff = module.in_features - x.size(-1)
            if diff > 0:                      # Áª¥Â∫¶‰∏çË∂≥ ‚Üí pad 0
                x = F.pad(x, (0, diff))
            else:                             # Áª¥Â∫¶ËøáÂ§ö ‚Üí Êà™Êñ≠
                x = x[..., :module.in_features]
        return (x,)

    for m in net.modules():
        if isinstance(m, nn.Linear):
            m.register_forward_pre_hook(pre_hook)

    net._patched_generic = True
    return net
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÊùÉÈáçÊü•Êâæ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def find_ckpt(root: str, ds: str, model_key: str):
    cand_roots = [
        root,                                # Áî®Êà∑‰º†ÂÖ•
        os.path.join(HERE, "models"),        # ./models
        os.path.join(HERE, "..", "models"),  # ../models
    ]
    for r in cand_roots:
        ck = os.path.join(r, ds, model_key, "best_model.pth")
        if os.path.isfile(ck):
            return ck
    raise FileNotFoundError(
        "‚ùå Êú™ÊâæÂà∞ÊùÉÈáçÊñá‰ª∂ best_model.pthÔºõÊêúÁ¥¢Ë∑ØÂæÑÔºö\n  " +
        "\n  ".join(os.path.join(r, ds, model_key) for r in cand_roots)
    )

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‰∏ªÊµÅÁ®ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def main():
    a = cli()
    if a.model in a.skip.split(","):
        print(f"‚è© Skip {a.model} by user option")
        return

    ckpt = find_ckpt(a.model_root, a.dataset, a.model)
    net, ncls = load_net(ckpt, a.model, a.dataset)
    tbl = tag_table(a.dataset, ncls)

    auds = list_audio(a.audio_folder, a.exts)
    if not auds:
        print("‚ùó Êú™ÊâæÂà∞Èü≥È¢ëÊñá‰ª∂"); return

    date = datetime.now().strftime("%Y%m%d")
    csv_f = f"results_{a.dataset}_{a.model}_{date}.csv"
    js_f  = f"results_{a.dataset}_{a.model}_{date}.json"
    first_write = not os.path.exists(csv_f)
    js_buf = {}

    with open(csv_f, "a", newline='', encoding="utf-8") as fp:
        wr = csv.writer(fp)
        if first_write:
            head = ["file", "model"]
            for k in range(1, a.top_k + 1):
                head += [f"tag_en_{k}", f"tag_zh_{k}", f"prob_{k}"]
            wr.writerow(head)

        for p in auds:
            x = wav_tensor(p).to(device)
            probs = torch.sigmoid(net(x)).flatten()
            picks = sorted(
                [(i, float(pr)) for i, pr in enumerate(probs) if pr >= a.th],
                key=lambda t: t[1], reverse=True)[:a.top_k]

            row = [os.path.basename(p), a.model]
            js_list = []
            for idx, pr in picks:
                en, zh = tbl[idx] if idx < len(tbl) else (f"tag_{idx:03d}",)*2
                row += [en, zh, round(pr, 3)]
                js_list.append({"tag_en": en, "tag_zh": zh, "prob": round(pr, 3)})
            row += ["", "", ""] * (a.top_k - len(picks))  # Ë°•ÈΩê
            wr.writerow(row); print(",".join(map(str, row)))
            js_buf[os.path.basename(p)] = {"model": a.model, "predictions": js_list}

    with open(js_f, "w", encoding="utf-8") as jf:
        json.dump(js_buf, jf, ensure_ascii=False, indent=2)
    print(f"‚úÖ ÁªìÊûúÂ∑≤‰øùÂ≠òÔºö{csv_f}  Âíå  {js_f}")

if __name__ == "__main__":
    main()